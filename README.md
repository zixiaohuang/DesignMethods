# DesignMethods
Study different design methods and code by myself in C++

面向对象的精神就是更好地应对需求的变化，提高复用性，而设计模式就是能够帮助我们做出应对变化，提高复用性的设计方案。

内聚性：一个例程内部组成之间相互联系的紧密程度
耦合性：一个例程与其他例程之间联系的紧密程度
软件开发的目标应该是创建这样的一个例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧，直接，可见，灵活的，这就是松耦合。

/*创建型模式*/
创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。
当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些。

抽象工厂(Abstract Factory)：提供一个创建一系列或相关依赖对象的接口，而无需指定它具体的类型//可以解决多个类型产品的创建问题

建造者(Bulider)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
      //把建造过程隐藏，一个请求，完整产品就创建
      //将一个复杂对象的构建与它的表示分离，这就可以很容易地改变一个产品的内部表示，并且使得构造代码和表示代码分开。
      
工厂方法(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类

原型(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

单例(Singleton)：保证一个类仅有一个实例，并提供一个访问它的安全访问点
    //让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且提供一个访问该实例的方法。这就使得对唯一实例可以严格地控制客户怎样以及何时访问它。
     
/*结构型模式*/

适配器(Adapter)：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

桥接(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。

组合：将对象组合成树型结构以表示‘部分-整体’的层次结构，组合模式使得用户对单对象和组合对象的使用具有一致性。

装饰：动态地给一个对象添加额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活。

外观：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

享元：为运用共享技术有效地支持大量细粒度的对象

代理：为其他对象提供一种代理以控制对这个对象的访问

