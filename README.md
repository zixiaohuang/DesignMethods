# DesignMethods
Study different design methods and code by myself in C++

面向对象的精神就是更好地应对需求的变化，提高复用性，而设计模式就是能够帮助我们做出应对变化，提高复用性的设计方案。

内聚性：一个例程内部组成之间相互联系的紧密程度
耦合性：一个例程与其他例程之间联系的紧密程度
软件开发的目标应该是创建这样的一个例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧，直接，可见，灵活的，这就是松耦合。

/*创建型模式*/
创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。
当一个系统应该独立于它的产品创建、构成和表示时，应该考虑用创建性模式。建立相应数目的原型并克隆它们通常比每次用合适的状态手工实例化该类更方便一些。

抽象工厂(Abstract Factory)：提供一个创建一系列或相关依赖对象的接口，而无需指定它具体的类型//可以解决多个类型产品的创建问题

建造者(Bulider)：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示
      //把建造过程隐藏，一个请求，完整产品就创建
      //将一个复杂对象的构建与它的表示分离，这就可以很容易地改变一个产品的内部表示，并且使得构造代码和表示代码分开。
      
工厂方法(Factory Method)：定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到其子类

原型(Prototype)：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象

单例(Singleton)：保证一个类仅有一个实例，并提供一个访问它的安全访问点
    //让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且提供一个访问该实例的方法。这就使得对唯一实例可以严格地控制客户怎样以及何时访问它。
     
/*结构型模式*/

适配器(Adapter)：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

桥接(Bridge)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。//设计之初

组合(Composite)：将对象组合成树型结构以表示‘部分-整体’的层次结构，组合模式使得用户对单对象和组合对象的使用具有一致性。

装饰(Decorator)：动态地给一个对象添加额外的职责，就增加功能来说，装饰模式相比生成子类更加灵活。

外观(Facade)：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。//应该让一个软件中的子系统间的通信和相互依赖关系达到最小，而具体办法就是引入一个外观对象，它为子系统间提供了一个单一而简单的屏障

享元(Flyweight)：为运用共享技术有效地支持大量细粒度的对象//对象使得内存占用过多，如果都是大量重复的对象，就是极大资源浪费

代理(Proxy)：为其他对象提供一种代理以控制对这个对象的访问

/*行为型模式*/

观察者(Observer)：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

模版方法(TemplateMethod)：定义一个操作的算法骨架，而将一些步骤延迟到子类中，模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
        //代码重复是编程中最常见、最糟糕的‘坏味道’，如果我们在一个以上的地方看到相同的程序，那么可以肯定，设法将它们合而为一，程序会变得更好。
        //模版方法模式由一个抽象类组成，这个抽象类定义了需要覆盖的可能有不同实现的模版方法，每个从这个抽象类派生的具体类将为此模版实现新方法。

命令(Command)：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；可以对请求排队或记录请求日志，以及支持可撤销的操作。

状态(State)：允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类。//状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态的逻辑不在单块的if或switch中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换。

职责链(Chian of Responsibility)：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。 //有多个对象可以处理一个请求，哪个对象处理该请求事先并不知道，要在运行时刻自动确定，此时，最好的办法就是让请求发送者与具体处理者分离，让客户在不明确指定接收者的情况下，提交一个请求，然后由所有能够处理这请求的对象连城一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

解释器(Interpreter)：给定一个语言，定义它的文法的一种表示，并定义了一个解释器，这个解释器使用该表示来解释语言中的句子。
                  //如果一个特定类型的问题发生的频率足够高，那么就可以考虑将该问题的各个实例表述为一个简单语言中的句子。也就是说，通过构建一个解释器，该解释器解释这些句子来解决该问题。

中介者(Mediator)：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
                 //对象间的大量相互链接使得一个对象似乎不太可能在没有其他对象的支持下工作，这对于应对变化是不利的，任何改动都很困难。
                 //将集体行为封装一个单独的中介者来避免这个问题，中介者负责控制和协调一组对象间的交互。中介者充当一个中介以使组中的对着不再相互显示引用。这些对象仅知道中介者，从而减少来相互链接的数目。

访问者(Visitor)：表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。

策略(Strategy)：定义一系列算法，把它们一个个封装起来，并且使它们可互相替换。本模式使得算法可独立于使用它的客户而变化。//优先使用对象组合，而非类继承

备忘录(Memento)：在不破坏封装性前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
               //可以避免暴露一些只由对象A管理却又必须存储在对象A之外的信息。备忘录把可能很复杂的对象A的内部信息对其他对象屏蔽起来，从而保持了封装边界。

迭代器(Iterator)：提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示。
                 //迭代器模式的关键思想是将对列表的访问和遍历从列表对象中分离出来并放入一个迭代器对象中，迭代器类定义了一个访问该列表元素的接口。
                 迭代器对象负责跟踪当前的元素，并且知道哪些元素已经遍历过了。 


